import { Request, Response, NextFunction } from 'express';
import Analytics from '../models/Analytics';
import UserSession from '../models/UserSession';
import { Project } from '../models/Project';
import { v4 as uuidv4 } from 'uuid';
import mongoose from 'mongoose';

interface AuthenticatedRequest extends Request {
  userId?: string;
  user?: any;
}

// Event throttling cache to prevent over-tracking
const eventThrottleCache = new Map<string, number>();
const projectAccessCache = new Map<string, number>();

// Consolidated and optimized Analytics service class
export class AnalyticsService {
  // Event throttling durations (in milliseconds)
  private static readonly THROTTLE_DURATIONS: Record<string, number> = {
    page_view: 30000,      // 30 seconds
    project_open: 60000,   // 1 minute  
    field_edit: 5000,      // 5 seconds
    ui_interaction: 10000, // 10 seconds
    heartbeat: 300000,     // 5 minutes
    action: 15000,         // 15 seconds
    feature_usage: 20000,  // 20 seconds
    navigation: 10000,     // 10 seconds
    search: 5000,          // 5 seconds
    error: 0,              // Never throttle errors
    performance: 30000,    // 30 seconds
    session_start: 0,      // Never throttle
    session_end: 0         // Never throttle
  };

  // Critical events that should never be throttled
  private static readonly CRITICAL_EVENTS = new Set([
    'session_start',
    'session_end', 
    'error',
    'security_event'
  ]);
  static async trackEvent(
    userId: string,
    eventType: 'project_open' | 'field_edit' | 'session_start' | 'session_end' | 'page_view' | 'action' | 'feature_usage' | 'navigation' | 'search' | 'error' | 'performance' | 'ui_interaction' | 'heartbeat',
    eventData: any,
    req?: Request
  ) {
    try {
      // Check if this event should be throttled
      if (!this.CRITICAL_EVENTS.has(eventType)) {
        const cacheKey = `${userId}-${eventType}-${JSON.stringify(eventData)}`;
        const now = Date.now();
        const lastTracked = eventThrottleCache.get(cacheKey);
        const throttleDuration = this.THROTTLE_DURATIONS[eventType] || 30000;

        if (lastTracked && (now - lastTracked) < throttleDuration) {
          // Event is throttled, skip tracking
          return null;
        }

        // Update throttle cache
        eventThrottleCache.set(cacheKey, now);
      }

      // Clean up old cache entries periodically (every 1000 events)
      if (Math.random() < 0.001) {
        this.cleanThrottleCache();
      }

      const analyticsData = new Analytics({
        userId,
        sessionId: req?.headers['x-session-id'] as string,
        eventType,
        eventData: this.sanitizeEventData(eventData),
        timestamp: new Date(),
        userAgent: req?.headers['user-agent'],
        ipAddress: this.getClientIP(req)
      });

      await analyticsData.save();

      // Update session if exists
      if (req?.headers['x-session-id']) {
        await this.updateSession(req.headers['x-session-id'] as string, eventData);
      }

      return analyticsData;
    } catch (error) {
      console.error('Error tracking analytics event:', error);
      return null;
    }
  }

  // Sanitize event data to prevent bloat and security issues
  private static sanitizeEventData(eventData: any): any {
    if (!eventData || typeof eventData !== 'object') {
      return eventData;
    }

    const sanitized: any = {};
    
    // Limit the depth and size of event data
    for (const [key, value] of Object.entries(eventData)) {
      if (key.length > 100) continue; // Skip very long keys
      
      if (typeof value === 'string' && value.length > 1000) {
        sanitized[key] = value.substring(0, 1000) + '...';
      } else if (typeof value === 'object' && value !== null) {
        // Flatten nested objects to prevent deep nesting
        sanitized[key] = JSON.stringify(value).substring(0, 500);
      } else {
        sanitized[key] = value;
      }
    }

    return sanitized;
  }

  // Get client IP address with fallbacks
  private static getClientIP(req?: Request): string {
    if (!req) return 'unknown';
    
    return (
      req.headers['x-forwarded-for'] as string ||
      req.headers['x-real-ip'] as string ||
      req.connection?.remoteAddress ||
      req.socket?.remoteAddress ||
      'unknown'
    );
  }

  // Clean up old throttle cache entries
  private static cleanThrottleCache(): void {
    const now = Date.now();
    const maxAge = 10 * 60 * 1000; // 10 minutes

    for (const [key, timestamp] of eventThrottleCache.entries()) {
      if (now - timestamp > maxAge) {
        eventThrottleCache.delete(key);
      }
    }
  }

  static async startSession(userId: string, req: Request): Promise<string> {
    try {
      const sessionId = uuidv4();
      
      const session = new UserSession({
        userId,
        sessionId,
        startTime: new Date(),
        lastActivity: new Date(),
        userAgent: req.headers['user-agent'],
        ipAddress: this.getClientIP(req),
        isActive: true
      });

      await session.save();

      // Track session start event
      await this.trackEvent(userId, 'session_start', { sessionId }, req);

      return sessionId;
    } catch (error) {
      console.error('Error starting session:', error);
      return uuidv4(); // Return a session ID even if DB fails
    }
  }

  static async endSession(sessionId: string, userId?: string) {
    try {
      const session = await UserSession.findOne({ sessionId, isActive: true });
      if (!session) return;

      const endTime = new Date();
      const duration = endTime.getTime() - session.startTime.getTime();

      // Save time spent on current project before ending session
      if (session.currentProjectId && session.currentProjectStartTime) {
        const timeSpent = endTime.getTime() - session.currentProjectStartTime.getTime();
        
        // Find existing project time entry or create new one
        let existingProject = session.projectTimeBreakdown?.find(
          p => p.projectId === session.currentProjectId
        );
        
        if (existingProject) {
          existingProject.timeSpent += timeSpent;
          existingProject.lastSwitchTime = endTime;
        } else {
          if (!session.projectTimeBreakdown) {
            session.projectTimeBreakdown = [];
          }
          session.projectTimeBreakdown.push({
            projectId: session.currentProjectId,
            timeSpent,
            lastSwitchTime: endTime
          });
        }
        
        console.log(`Analytics: Saved ${Math.round(timeSpent / 1000)}s for project ${session.currentProjectId} before ending session`);
      }

      // Update session with final data
      session.endTime = endTime;
      session.duration = duration;
      session.isActive = false;
      await session.save();

      // Track session end event
      if (userId) {
        await this.trackEvent(userId, 'session_end', { 
          sessionId, 
          duration: Math.round(duration / 1000), // duration in seconds
          currentProjectTime: session.currentProjectId && session.currentProjectStartTime ? 
            Math.round((endTime.getTime() - session.currentProjectStartTime.getTime()) / 1000) : 0
        });
      }
    } catch (error) {
      console.error('Error ending session:', error);
    }
  }

  static async updateSession(sessionId: string, eventData: any) {
    try {
      const updateData: any = {
        lastActivity: new Date(),
        $inc: { totalEvents: 1 }
      };

      // Handle heartbeat updates differently
      if (eventData.heartbeat) {
        updateData.lastActivity = eventData.timestamp || new Date();
        // Don't increment totalEvents for heartbeats
        delete updateData.$inc;
        
        // Track visibility state if provided
        if (typeof eventData.isVisible === 'boolean') {
          updateData.isVisible = eventData.isVisible;
        }

        // Track current project and page
        if (eventData.currentProjectId) {
          updateData.currentProjectId = eventData.currentProjectId;
        }
        if (eventData.currentPage) {
          updateData.currentPage = eventData.currentPage;
        }
      } else {
        // Regular event updates
        if (eventData.projectId) {
          updateData.$addToSet = { projectsViewed: eventData.projectId };
        }

        if (eventData.pageName) {
          updateData.$addToSet = { 
            ...updateData.$addToSet,
            pagesVisited: eventData.pageName 
          };
        }
      }

      await UserSession.updateOne({ sessionId }, updateData);
    } catch (error) {
      console.error('Error updating session:', error);
    }
  }

  // New consolidated method for project switching with time tracking
  static async switchProject(userId: string, sessionId: string, newProjectId: string) {
    try {
      const session = await UserSession.findOne({ sessionId, userId, isActive: true });
      if (!session) {
        throw new Error('Active session not found');
      }

      const now = new Date();
      
      // If switching FROM a project, record time spent
      if (session.currentProjectId && session.currentProjectStartTime) {
        const timeSpent = now.getTime() - session.currentProjectStartTime.getTime();
        
        // Find existing project time entry or create new one
        let existingProject = session.projectTimeBreakdown?.find(
          p => p.projectId === session.currentProjectId
        );
        
        if (existingProject) {
          existingProject.timeSpent += timeSpent;
          existingProject.lastSwitchTime = now;
        } else {
          if (!session.projectTimeBreakdown) {
            session.projectTimeBreakdown = [];
          }
          session.projectTimeBreakdown.push({
            projectId: session.currentProjectId,
            timeSpent,
            lastSwitchTime: now
          });
        }
      }

      // Switch to new project
      session.currentProjectId = newProjectId;
      
      // Set project start time - if this is a brand new session (no previous project),
      // use the session start time instead of now to capture all time since session began
      if (newProjectId) {
        if (!session.currentProjectStartTime) {
          // This is the first project set for this session, use session start time
          session.currentProjectStartTime = session.startTime;
          console.log(`Analytics: Setting project start time to session start for new session: ${session.sessionId}`);
        } else {
          // This is a project switch, use current time
          session.currentProjectStartTime = now;
        }
      } else {
        session.currentProjectStartTime = undefined;
      }
      
      session.lastActivity = now;
      
      // Add to projectsViewed if not already there
      if (newProjectId && !session.projectsViewed.includes(newProjectId)) {
        session.projectsViewed.push(newProjectId);
      }

      await session.save();
      return { success: true };
    } catch (error) {
      console.error('Error switching project:', error);
      return { success: false, error: error.message };
    }
  }

  // Get projects time data for a user
  static async getProjectTimeData(userId: string, days: number = 30) {
    try {
      const startDate = new Date();
      startDate.setDate(startDate.getDate() - days);

      // Aggregate project time from all user sessions
      const sessions = await UserSession.aggregate([
        {
          $match: {
            userId: userId,
            startTime: { $gte: startDate },
            projectTimeBreakdown: { $exists: true, $ne: [] }
          }
        },
        {
          $unwind: '$projectTimeBreakdown'
        },
        {
          $group: {
            _id: '$projectTimeBreakdown.projectId',
            totalTime: { $sum: '$projectTimeBreakdown.timeSpent' },
            sessions: { $sum: 1 },
            lastUsed: { $max: '$projectTimeBreakdown.lastSwitchTime' }
          }
        },
        {
          $sort: { totalTime: -1 }
        }
      ]);

      return { projects: sessions, period: `${days} days` };
    } catch (error) {
      console.error('Error fetching project time data:', error);
      return null;
    }
  }

  // Get specific project time data with daily breakdown
  static async getProjectTimeBreakdown(userId: string, projectId: string, days: number = 30) {
    try {
      const startDate = new Date();
      startDate.setDate(startDate.getDate() - days);

      const projectTime = await UserSession.aggregate([
        {
          $match: {
            userId: userId,
            startTime: { $gte: startDate },
            'projectTimeBreakdown.projectId': projectId
          }
        },
        {
          $unwind: '$projectTimeBreakdown'
        },
        {
          $match: {
            'projectTimeBreakdown.projectId': projectId
          }
        },
        {
          $group: {
            _id: {
              date: {
                $dateToString: {
                  format: '%Y-%m-%d',
                  date: '$projectTimeBreakdown.lastSwitchTime'
                }
              }
            },
            dailyTime: { $sum: '$projectTimeBreakdown.timeSpent' },
            sessions: { $sum: 1 }
          }
        },
        {
          $sort: { '_id.date': 1 }
        }
      ]);

      const totalTime = projectTime.reduce((sum, day) => sum + day.dailyTime, 0);

      return {
        projectId,
        totalTime,
        dailyBreakdown: projectTime,
        period: `${days} days`
      };
    } catch (error) {
      console.error('Error fetching project time breakdown:', error);
      return null;
    }
  }

  // Get team time data for a project
  static async getTeamProjectTime(userId: string, projectId: string, days: number = 30) {
    try {
      const startDate = new Date();
      startDate.setDate(startDate.getDate() - days);

      // First, get all team members for this project
      const project = await Project.findById(projectId).select('userId').lean();
      
      if (!project) {
        throw new Error('Project not found');
      }

      // Get team members from TeamMember collection
      const TeamMember = await import('../models/TeamMember');
      const teamMembers = await TeamMember.default.find({ projectId }).populate('userId', 'firstName lastName email').lean();
      
      // Get all user IDs (owner + team members)
      const userIds = [project.userId.toString()];
      if (teamMembers?.length > 0) {
        userIds.push(...teamMembers.map((m: any) => m.userId._id.toString()));
      }

      const objectIdUserIds = userIds.map(id => new mongoose.Types.ObjectId(id));

      // Get current active sessions for all team members
      const activeSessions = await UserSession.find({
        userId: { $in: objectIdUserIds },
        isActive: true
      }).lean();

      const teamTimeData: any[] = [];
      
      // For each team member, calculate their total time on this project
      for (const userIdStr of userIds) {
        const userObjectId = new mongoose.Types.ObjectId(userIdStr);
        
        // Get all sessions for this user that have project time data
        const userSessions = await UserSession.find({
          userId: userObjectId,
          projectTimeBreakdown: { $exists: true, $ne: [] }
        }).lean();
        
        let totalTime = 0;
        let lastUsed: Date | null = null;
        
        userSessions.forEach(session => {
          const projectEntry = session.projectTimeBreakdown?.find(p => 
            p.projectId === projectId || p.projectId?.toString() === projectId
          );
          if (projectEntry) {
            totalTime += projectEntry.timeSpent || 0;
            if (!lastUsed || projectEntry.lastSwitchTime > lastUsed) {
              lastUsed = projectEntry.lastSwitchTime;
            }
          }
        });
        
        // Check for current active session with this project
        const activeSession = activeSessions.find(s => s.userId.toString() === userIdStr);
        if (activeSession && activeSession.currentProjectId === projectId && activeSession.currentProjectStartTime) {
          const currentSessionTime = Date.now() - activeSession.currentProjectStartTime.getTime();
          totalTime += currentSessionTime;
          lastUsed = new Date();
        }
        
        // Always include team members in the result, even with 0 time
        teamTimeData.push({
          _id: userObjectId,
          totalTime,
          sessions: userSessions.length,
          lastUsed
        });
      }

      return {
        projectId,
        teamTimeData,
        period: `${days} days`
      };
    } catch (error) {
      console.error('Error fetching team project time data:', error);
      return null;
    }
  }

  // Helper method to get analytics for specific event type
  private static async getEventAnalytics(eventType: string, startDate: Date) {
    try {
      return await Analytics.aggregate([
        {
          $match: {
            eventType,
            timestamp: { $gte: startDate }
          }
        },
        {
          $group: {
            _id: {
              eventType: '$eventType',
              data: { $ifNull: ['$eventData', {}] }
            },
            count: { $sum: 1 },
            latestTimestamp: { $max: '$timestamp' },
            users: { $addToSet: '$userId' }
          }
        },
        {
          $project: {
            eventType: '$_id.eventType',
            eventData: '$_id.data',
            count: 1,
            uniqueUsers: { $size: '$users' },
            latestTimestamp: 1
          }
        },
        {
          $sort: { count: -1 }
        },
        {
          $limit: 50
        }
      ]);
    } catch (error) {
      console.error(`Error fetching ${eventType} analytics:`, error);
      return [];
    }
  }

  // Legacy method for compatibility with routes
  static async runQuery(eventType: string, params: any[]) {
    const days = parseInt(params[0]) || 30;
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - days);

    switch (eventType) {
      case 'feature_usage':
        const features = await this.getEventAnalytics('feature_usage', startDate);
        return features.map(f => ({
          feature_name: f.eventData?.feature || f.eventData?.featureName || 'Unknown',
          usage_count: f.count,
          unique_users: f.uniqueUsers
        }));

      case 'navigation':
        const nav = await this.getEventAnalytics('navigation', startDate);
        return nav.map(n => ({
          from_page: n.eventData?.from || 'Unknown',
          to_page: n.eventData?.to || n.eventData?.page || 'Unknown',
          count: n.count
        }));

      case 'search':
        const searches = await this.getEventAnalytics('search', startDate);
        return searches.map(s => ({
          search_term: s.eventData?.query || s.eventData?.searchTerm || 'Empty Query',
          search_count: s.count,
          avg_results: s.eventData?.results || 0
        }));

      case 'error':
        const errors = await this.getEventAnalytics('error', startDate);
        return errors.map(e => ({
          error_type: e.eventData?.type || e.eventData?.errorType || 'Unknown Error',
          error_count: e.count,
          error_message: e.eventData?.message || 'No message'
        }));

      case 'performance':
        const perf = await this.getEventAnalytics('performance', startDate);
        return perf.map(p => ({
          action_type: p.eventData?.action || p.eventData?.actionType || 'Unknown Action',
          avg_duration: p.eventData?.duration || 0,
          count: p.count
        }));

      case 'ui_interaction':
        const ui = await this.getEventAnalytics('ui_interaction', startDate);
        return ui.map(u => ({
          interaction_type: u.eventData?.type || u.eventData?.interactionType || 'Unknown Interaction',
          interaction_count: u.count,
          element: u.eventData?.element || 'Unknown'
        }));

      default:
        return [];
    }
  }

  // Get comprehensive analytics with all event types
  static async getComprehensiveAnalytics(userId: string, days: number = 30) {
    try {
      const startDate = new Date();
      startDate.setDate(startDate.getDate() - days);

      const [
        featureUsage,
        navigation, 
        searches,
        errors,
        performance,
        uiInteractions,
        pageViews,
        projectOpens,
        fieldEdits,
        actions,
        heartbeats
      ] = await Promise.all([
        this.getEventAnalytics('feature_usage', startDate),
        this.getEventAnalytics('navigation', startDate),
        this.getEventAnalytics('search', startDate),
        this.getEventAnalytics('error', startDate),
        this.getEventAnalytics('performance', startDate),
        this.getEventAnalytics('ui_interaction', startDate),
        this.getEventAnalytics('page_view', startDate),
        this.getEventAnalytics('project_open', startDate),
        this.getEventAnalytics('field_edit', startDate),
        this.getEventAnalytics('action', startDate),
        this.getEventAnalytics('heartbeat', startDate)
      ]);

      return {
        featureUsage,
        navigation,
        searches,
        errors,
        performance,
        uiInteractions,
        pageViews,
        projectOpens,
        fieldEdits,
        actions,
        heartbeats,
        summary: {
          totalFeatureUsage: featureUsage.length,
          totalNavigationEvents: navigation.length,
          totalSearches: searches.length,
          totalErrors: errors.length,
          totalPerformanceEvents: performance.length,
          totalUIInteractions: uiInteractions.length,
          totalPageViews: pageViews.length,
          totalProjectOpens: projectOpens.length,
          totalFieldEdits: fieldEdits.length,
          totalActions: actions.length,
          totalHeartbeats: heartbeats.length
        }
      };
    } catch (error) {
      console.error('Error fetching comprehensive analytics:', error);
      return null;
    }
  }

  // Helper method to get analytics for specific event type
  private static async getEventAnalytics(eventType: string, startDate: Date) {
    try {
      return await Analytics.aggregate([
        {
          $match: {
            eventType,
            timestamp: { $gte: startDate }
          }
        },
        {
          $group: {
            _id: {
              eventType: '$eventType',
              data: { $ifNull: ['$eventData', {}] }
            },
            count: { $sum: 1 },
            latestTimestamp: { $max: '$timestamp' },
            users: { $addToSet: '$userId' }
          }
        },
        {
          $project: {
            eventType: '$_id.eventType',
            eventData: '$_id.data',
            count: 1,
            uniqueUsers: { $size: '$users' },
            latestTimestamp: 1
          }
        },
        {
          $sort: { count: -1 }
        },
        {
          $limit: 50
        }
      ]);
    } catch (error) {
      console.error(`Error fetching ${eventType} analytics:`, error);
      return [];
    }
  }

  static async getActiveSession(userId: string) {
    try {
      return await UserSession.findOne({ 
        userId, 
        isActive: true 
      }).sort({ startTime: -1 });
    } catch (error) {
      console.error('Error getting active session:', error);
      return null;
    }
  }

  static async getUserAnalytics(userId: string, days: number = 30) {
    try {
      const startDate = new Date();
      startDate.setDate(startDate.getDate() - days);

      const analytics = await Analytics.aggregate([
        {
          $match: {
            userId,
            timestamp: { $gte: startDate }
          }
        },
        {
          $group: {
            _id: '$eventType',
            count: { $sum: 1 },
            lastEvent: { $max: '$timestamp' }
          }
        }
      ]);

      const sessions = await UserSession.aggregate([
        {
          $match: {
            userId,
            startTime: { $gte: startDate }
          }
        },
        {
          $addFields: {
            calculatedDuration: {
              $cond: {
                if: { $and: [{ $gt: ['$duration', 0] }] },
                then: '$duration',
                else: {
                  $subtract: [
                    { $ifNull: ['$lastActivity', new Date()] },
                    '$startTime'
                  ]
                }
              }
            }
          }
        },
        {
          $group: {
            _id: null,
            totalSessions: { $sum: 1 },
            totalDuration: { $sum: '$calculatedDuration' },
            avgDuration: { $avg: '$calculatedDuration' },
            uniqueProjects: { $addToSet: '$projectsViewed' }
          }
        }
      ]);

      // Get project time breakdown data with simplified approach
      const projectTimeData = await UserSession.aggregate([
        {
          $match: {
            userId,
            startTime: { $gte: startDate },
            projectTimeBreakdown: { $exists: true, $ne: [] }
          }
        },
        {
          $unwind: '$projectTimeBreakdown'
        },
        {
          $group: {
            _id: '$projectTimeBreakdown.projectId',
            totalTime: { $sum: '$projectTimeBreakdown.timeSpent' },
            sessions: { $sum: 1 },
            lastUsed: { $max: '$projectTimeBreakdown.lastSwitchTime' }
          }
        },
        {
          $sort: { totalTime: -1 }
        }
      ]);

      // Get project names for the user to ensure we only get accessible projects
      const projectIds = projectTimeData.map(p => p._id).filter(id => id);
      
      // Convert string IDs to ObjectIds where possible
      const objectIds = projectIds.map(id => {
        try {
          return mongoose.Types.ObjectId.isValid(id) ? new mongoose.Types.ObjectId(id) : null;
        } catch (e) {
          return null;
        }
      }).filter(id => id !== null);
      
      // Import TeamMember model
      const TeamMember = (await import('../models/TeamMember')).default;
      
      // Get projects the user has access to (owned or team member)
      const teamMemberProjects = await TeamMember.find({ userId }).select('projectId').lean();
      const accessibleProjectIds = [...objectIds, ...teamMemberProjects.map(tm => tm.projectId)];
      
      // Query projects by accessible project IDs
      const projects = await Project.find({
        $or: [
          { userId: userId, _id: { $in: objectIds } }, // User-owned projects
          { _id: { $in: accessibleProjectIds } } // Team member projects
        ]
      }).select('_id name').lean();

      // Combine the data
      const projectBreakdown = projectTimeData.map(timeData => {
        const project = projects.find(p => 
          p._id.toString() === timeData._id?.toString()
        );
        
        return {
          projectId: timeData._id,
          projectName: project?.name || `Project ${timeData._id?.toString().slice(-6)}`,
          totalTime: timeData.totalTime,
          sessions: timeData.sessions,
          lastUsed: timeData.lastUsed
        };
      });

      return {
        eventCounts: analytics,
        sessionStats: sessions[0] || {},
        projectBreakdown: projectBreakdown,
        period: `${days} days`
      };
    } catch (error) {
      console.error('Error getting user analytics:', error);
      return null;
    }
  }

  // Legacy method for compatibility with routes
  static async runQuery(eventType: string, params: any[]) {
    const days = parseInt(params[0]) || 30;
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - days);

    switch (eventType) {
      case 'feature_usage':
        const features = await this.getEventAnalytics('feature_usage', startDate);
        return features.map(f => ({
          feature_name: f.eventData?.feature || f.eventData?.featureName || 'Unknown',
          usage_count: f.count,
          unique_users: f.uniqueUsers
        }));

      case 'navigation':
        const nav = await this.getEventAnalytics('navigation', startDate);
        return nav.map(n => ({
          from_page: n.eventData?.from || 'Unknown',
          to_page: n.eventData?.to || n.eventData?.page || 'Unknown',
          count: n.count
        }));

      case 'search':
        const searches = await this.getEventAnalytics('search', startDate);
        return searches.map(s => ({
          search_term: s.eventData?.query || s.eventData?.searchTerm || 'Empty Query',
          search_count: s.count,
          avg_results: s.eventData?.results || 0
        }));

      case 'error':
        const errors = await this.getEventAnalytics('error', startDate);
        return errors.map(e => ({
          error_type: e.eventData?.type || e.eventData?.errorType || 'Unknown Error',
          error_count: e.count,
          error_message: e.eventData?.message || 'No message'
        }));

      case 'performance':
        const perf = await this.getEventAnalytics('performance', startDate);
        return perf.map(p => ({
          action_type: p.eventData?.action || p.eventData?.actionType || 'Unknown Action',
          avg_duration: p.eventData?.duration || 0,
          count: p.count
        }));

      case 'ui_interaction':
        const ui = await this.getEventAnalytics('ui_interaction', startDate);
        return ui.map(u => ({
          interaction_type: u.eventData?.type || u.eventData?.interactionType || 'Unknown Interaction',
          interaction_count: u.count,
          element: u.eventData?.element || 'Unknown'
        }));

      default:
        return [];
    }
  }
}

// Optimized middleware to track page views with throttling
export const trackPageView = (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
  if (req.userId) {
    // Skip tracking for health checks and static assets
    if (req.path.includes('/health') || 
        req.path.includes('/static') || 
        req.path.includes('/favicon')) {
      return next();
    }

    // Track asynchronously with built-in throttling
    AnalyticsService.trackEvent(req.userId, 'page_view', {
      pageName: req.path,
      method: req.method,
      query: req.query
    }, req).catch(console.error);
  }
  next();
};

// Optimized middleware to track project access with intelligent caching
export const trackProjectAccess = (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
  if (!req.userId) {
    return next();
  }

  const projectId = req.params.id || req.params.projectId;
  if (!projectId) {
    return next();
  }

  // Check project access cache to avoid redundant tracking
  const cacheKey = `${req.userId}-${projectId}`;
  const now = Date.now();
  const lastAccess = projectAccessCache.get(cacheKey);
  
  if (lastAccess && (now - lastAccess) < 60000) { // 1 minute throttle
    return next();
  }

  const originalSend = res.send;
  
  res.send = function(data) {
    if (res.statusCode < 400) {
      projectAccessCache.set(cacheKey, now);
      
      // Track project access asynchronously without blocking the response
      (async () => {
        try {
          // Try to get project name from the response data first
          let projectName = 'Unknown Project';
          
          if (data && typeof data === 'string') {
            try {
              const parsedData = JSON.parse(data);
              if (parsedData.name) {
                projectName = parsedData.name;
              }
            } catch (e) {
              // Not JSON, continue with fallback
            }
          } else if (data && typeof data === 'object' && data.name) {
            projectName = data.name;
          }
          
          // If we still don't have a name, try to fetch it from the database
          if (projectName === 'Unknown Project') {
            const project = await Project.findById(projectId).select('name').lean();
            if (project) {
              projectName = project.name;
            }
          }

          AnalyticsService.trackEvent(req.userId!, 'project_open', {
            projectId,
            projectName,
            endpoint: req.path,
            method: req.method
          }, req).catch(console.error);
        } catch (error) {
          // Fallback to tracking without project name if there's an error
          AnalyticsService.trackEvent(req.userId!, 'project_open', {
            projectId,
            endpoint: req.path,
            method: req.method
          }, req).catch(console.error);
        }
      })();
    }
    return originalSend.call(this, data);
  };
  
  next();
};

// Optimized session middleware with smart updates
export const sessionMiddleware = async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
  try {
    if (req.userId) {
      let sessionId = req.headers['x-session-id'] as string;
      
      if (!sessionId) {
        // Start new session
        sessionId = await AnalyticsService.startSession(req.userId, req);
        res.set('X-Session-ID', sessionId);
      } else {
        // Only update session periodically, not on every request (optimization)
        const shouldUpdate = Math.random() < 0.1; // 10% of requests
        
        if (shouldUpdate) {
          await AnalyticsService.updateSession(sessionId, {
            pageName: req.path,
            lastActivity: new Date()
          });
        }
      }
    }
    
    next();
  } catch (error) {
    console.error('Session middleware error:', error);
    next(); // Continue even if session update fails
  }
};